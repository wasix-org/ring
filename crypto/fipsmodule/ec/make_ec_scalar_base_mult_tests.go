/* Copyright (c) 2018, Google Inc.
 *
 * Permission to use, copy, modify, and/or distribute this software for any
 * purpose with or without fee is hereby granted, provided that the above
 * copyright notice and this permission notice appear in all copies.
 *
 * THE SOFTWARE IS PROVIDED "AS IS" AND THE AUTHOR DISCLAIMS ALL WARRANTIES
 * WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF
 * MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY
 * SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES
 * WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION
 * OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF OR IN
 * CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE. */

// go run crypto/fipsmodule/ec/make_ec_scalar_base_mult_tests.go

package main

import (
	"crypto/elliptic"
	"fmt"
	"io"
	"math/big"
	"os"
	"path/filepath"
)

const (
	// The number of bits in a window for windowed point multiplication.
	// XXX: *ring*'s tests were generated for 7 bit windows, but the code
	// currently uses 5 bit windows.
	windowBits = 6

	// 2 windows worth of points.
	numPoints = 2 * (1 << windowBits)
)

func main() {
	generateTests(elliptic.P256())
	generateTests(elliptic.P384())
	//generateTests(elliptic.P521())
}

func generateTests(curve elliptic.Curve) {
	generateScalarMulBaseTests(curve)
}

func generateScalarMulBaseTests(curve elliptic.Curve) {
	f, err := createFile(curve, "point_mul_base")
	if err != nil {
		return
	}
	defer f.Close()

	fmt.Fprintf(f, `# This file contains multiples of the base point for various curves.
#
# This file is generated by make_ec_scalar_base_mult_tests.go

`)

	// Test low scalar values.
	for i := 0; i <= numPoints; i++ {
		n := new(big.Int)
		n.SetInt64(int64(i))
		printScalarMulBase(f, n, curve)
	}
	// Test each bit set at the high end.
	for i := 1; i < numPoints; i++ {
		n := new(big.Int)
		n.SetInt64(int64(i))
		n.Lsh(n, (uint)(curve.Params().N.BitLen()-windowBits-1))
		printScalarMulBase(f, n, curve)
	}
	// Test highest (negative) scalar values.
	for i := -numPoints; i <= -1; i++ {
		n := new(big.Int)
		n.SetInt64(int64(i))
		printScalarMulBase(f, n, curve)
	}
}

func printScalarMulBase(f io.Writer, n *big.Int, curve elliptic.Curve) {
	if n.Sign() >= 0 && n.BitLen() <= 8 {
		fmt.Fprintf(f, "g_scalar = %02x\n", n)
	} else {
		if n.Sign() < 0 {
			neg := new(big.Int)
			fmt.Fprintf(f, "# g_scalar = n - %d\n", neg.Neg(n))
			n = n.Add(n, curve.Params().N)
		}
		fmt.Fprintf(f, "g_scalar = %x\n", padded(n, curve.Params().N))
	}
	x, y := curve.ScalarBaseMult(n.Bytes())
	printAffine(f, "r", x, y, curve.Params().P)
	fmt.Fprintf(f, "\n")
}

func printAffine(f io.Writer, key string, x, y, max *big.Int) {
	if x.BitLen() == 0 && y.BitLen() == 0 {
		fmt.Fprintf(f, "%s = inf\n", key)
	} else {
		fmt.Fprintf(f, "%s = %x, %x\n", key, padded(x, max), padded(y, max))
	}
}

func padded(n, max *big.Int) []byte {
	padded := make([]byte, len(max.Bytes()))
	b := n.Bytes()
	copy(padded[len(padded)-len(b):], b)
	return padded
}

func createFile(curve elliptic.Curve, baseName string) (*os.File, error) {
	outFileName := fmt.Sprintf("p%d_%s_tests.txt", curve.Params().N.BitLen(), baseName)
	return os.Create(filepath.Join("src/ec/suite_b/ops", outFileName))
}
